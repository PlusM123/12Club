# 12Club 项目开发规范

## 项目概述

12Club 是一个专为南开大学ACG（动画、漫画、轻小说）爱好者打造的综合性资源分享平台。项目提供动漫在线观看、音乐播放、资源下载、用户社区等功能，致力于创建一个活跃的ACG文化交流社区。

## 技术栈

### 核心框架
- **前端框架**: Next.js 15.5.5 (App Router + Turbopack)
- **UI库**: React 19.2.0 + TypeScript 5.9.3
- **状态管理**: Zustand 5.0.3
- **样式**: Tailwind CSS 4.1.14 + Sass 1.84.0

### UI组件与设计
- **组件库**: HeroUI 2.8.5 (@heroui/react)
- **图标**: Lucide React 0.468.0 + Tabler Icons 3.30.0 + React Icons 5.4.0
- **动画**: Framer Motion 11.15.0
- **主题**: Next Themes 0.4.4 (支持暗黑模式)
- **轮播**: Swiper 11.1.15
- **样式工具**: Class Variance Authority 0.7.1 + clsx 2.1.1 + Tailwind Merge 2.6.0

### 数据与后端
- **数据库**: Prisma 6.12.0 ORM + Prisma Accelerate 2.0.2
- **认证**: JWT (jsonwebtoken 9.0.2) + Supabase SSR 0.5.2
- **存储**: AWS S3 SDK 3.758.0 + AList Storage
- **缓存**: IORedis 5.6.0
- **数据生成**: Faker.js 9.3.0
- **安全**: @noble/hashes 1.7.1

### 媒体处理
- **视频播放器**: Plyr 3.7.8 + Artplayer 5.3.0
- **图片处理**: Sharp 0.33.5 + React Image Crop 11.0.7
- **代码高亮**: Sugar-high 0.9.2

### 表单与验证
- **表单管理**: React Hook Form 7.54.2
- **数据验证**: Zod 3.24.2
- **表单解析器**: @hookform/resolvers 4.1.3

### 工具与优化
- **时间处理**: Day.js 1.11.13
- **防抖**: use-debounce 10.0.4
- **本地存储**: localforage 1.10.0
- **进度条**: next-nprogress-bar 2.4.4
- **视图过渡**: next-view-transitions 0.3.4
- **热键**: react-hotkeys-hook 4.6.1
- **通知**: react-hot-toast 2.5.2
- **系统信息**: systeminformation 5.27.7
- **内容处理**: MDX (next-mdx-remote 5.0.0) + gray-matter 4.0.3 + html-to-text 9.0.5
- **安全**: isomorphic-dompurify 2.28.0

### 开发工具
- **代码格式化**: Prettier 3.4.2
- **代码检查**: ESLint 8 + eslint-config-next 15.5.5
- **Tailwind插件**: @tailwindcss/postcss 4.1.14 + @tailwindcss/aspect-ratio 0.4.2 + @tailwindcss/line-clamp 0.4.4 + tailwindcss-animate 1.0.7

## 编码规范

### 代码格式 (Prettier)
```json
{
  "singleQuote": true,           // 使用单引号
  "semi": false,                 // 不使用分号
  "tabWidth": 2,                 // 2个空格缩进
  "useTabs": false,              // 使用空格而非Tab
  "bracketSpacing": true,        // 大括号内部空格
  "trailingComma": "none",       // 不使用尾随逗号
  "endOfLine": "auto",           // 自动换行符
  "eslintIntegration": true,     // 集成ESLint
  "files.insertFinalNewline": true, // 文件末尾插入换行
  "htmlWhitespaceSensitivity": "strict" // HTML空白敏感度
}
```

### ESLint规则要点
- 强制使用2个空格缩进
- 要求使用全等运算符 (===)
- 限制函数参数最多5个
- 限制代码块嵌套深度最多3层
- 强制import语句排序和分组
- 禁止使用 `for...in` 循环
- 强制多行对象/数组使用尾随逗号
- 强制对象大括号内使用空格
- 限制连续空行数量
- 强制特定语句间的换行规则

### 命名约定

#### TypeScript类型定义
- **接口/类型**: PascalCase (例: `UserInfo`, `ResourceComment`, `AdminResource`)
- **枚举**: PascalCase (例: `UserRole`, `ResourceStatus`)
- **类型文件**: kebab-case (例: `user.d.ts`, `api/resource.d.ts`)

#### 组件与文件
- **组件名称**: PascalCase (例: `Footer`, `TopBar`, `SearchContainer`)
- **组件文件**: PascalCase.tsx (例: `Footer.tsx`, `UserProfile.tsx`)
- **Hook文件**: camelCase.ts (例: `useAuth.ts`, `useResourceData.ts`)
- **工具函数**: camelCase.ts (例: `formatTime.ts`, `apiClient.ts`)

#### 变量与函数
- **变量名**: camelCase (例: `userData`, `isLoading`, `resourceList`)
- **函数名**: camelCase (例: `getUserInfo`, `handleSubmit`, `validateForm`)
- **常量**: UPPER_SNAKE_CASE (例: `MAX_FILE_SIZE`, `API_ENDPOINTS`)

## 项目结构规范

### 实际项目结构
```
src/
├── app/                    # Next.js App Router页面
│   ├── admin/             # 管理后台页面
│   ├── anime/             # 动漫相关页面
│   ├── api/               # API路由
│   ├── doc/               # 文档页面
│   ├── edit/              # 编辑页面
│   ├── login/             # 登录页面
│   ├── register/          # 注册页面
│   ├── search/            # 搜索页面
│   ├── user/              # 用户页面
│   ├── actions.ts         # 服务端操作
│   ├── error.tsx          # 错误页面
│   ├── layout.tsx         # 根布局
│   ├── metadata.ts        # 元数据配置
│   ├── not-found.tsx      # 404页面
│   ├── page.tsx           # 首页
│   └── providers.tsx      # 全局提供者
├── components/            # React组件
│   ├── admin/             # 管理相关组件
│   ├── auth/              # 认证相关组件
│   ├── common/            # 通用组件
│   ├── doc/               # 文档组件
│   ├── edit/              # 编辑组件
│   ├── HomeContainer/     # 首页容器组件
│   ├── LoginRegister/     # 登录注册组件
│   ├── PageContainer/     # 页面容器组件
│   ├── SearchContainer/   # 搜索容器组件
│   ├── TopBar/            # 顶部导航组件
│   ├── user/              # 用户相关组件
│   └── ui/                # 基础UI组件
├── lib/                   # 核心库和工具
│   ├── mdx/               # MDX处理
│   ├── redis.ts           # Redis客户端
│   ├── routerTransition.ts # 路由过渡动画
│   ├── s3.ts              # AWS S3客户端
│   └── utils.ts           # 工具函数
├── utils/                 # 工具函数
├── hooks/                 # 自定义Hooks
│   ├── useMounted.ts      # 组件挂载状态
│   ├── useOutsideClick.tsx # 外部点击检测
│   └── useResizeObserver.ts # 尺寸观察器
├── store/                 # Zustand状态管理
│   ├── editStore.ts       # 编辑状态
│   ├── searchStore.ts     # 搜索状态
│   └── userStore.ts       # 用户状态
├── types/                 # TypeScript类型定义
│   ├── api/               # API类型
│   ├── common/            # 通用类型
│   └── user.d.ts          # 用户类型
├── validations/           # Zod验证模式
├── constants/             # 常量定义
├── config/                # 配置文件
├── styles/                # 全局样式
└── middleware/            # 中间件
```

### 组件开发规范

#### 组件结构模板
```tsx
'use client' // 如果是客户端组件

import React from 'react'
import { type ComponentProps } from 'react'

// 第三方库导入
import { Button } from '@heroui/react'
import { IconName } from 'lucide-react'

// 内部导入
import { cn } from '@/lib/utils'
import type { CustomType } from '@/types/component'

interface ComponentNameProps extends ComponentProps<'div'> {
  title: string
  isActive?: boolean
  onAction?: () => void
}

export const ComponentName: React.FC<ComponentNameProps> = ({
  title,
  isActive = false,
  onAction,
  className,
  ...props
}) => {
  // Hooks
  const [state, setState] = useState()
  
  // 事件处理函数
  const handleClick = () => {
    onAction?.()
  }

  return (
    <div 
      className={cn('base-classes', className)}
      {...props}
    >
      {title}
    </div>
  )
}
```

#### 导入顺序规范
1. React相关导入
2. 第三方库 (按字母顺序)
3. 内部组件和工具 (按字母顺序)
4. 类型导入 (使用 `type` 关键字)

### API与数据处理

#### 客户端API请求规范 (必须遵守)
**必须使用 `@/utils/fetch.ts` 中的统一封装方法，禁止直接使用原生 fetch API**

```typescript
// ✅ 正确示例
import { FetchGet, FetchPost, FetchPut, FetchDelete, FetchFormData } from '@/utils/fetch'

// GET 请求
const data = await FetchGet<ResponseType>('/endpoint', { id: '123' })

// POST 请求
const result = await FetchPost<ResponseType>('/endpoint', { name: 'value' })

// PUT 请求
const updated = await FetchPut<ResponseType>('/endpoint', { id: '123', name: 'new' })

// DELETE 请求
const deleted = await FetchDelete<ResponseType>('/endpoint', { id: '123' })

// FormData 上传
const formData = new FormData()
formData.append('file', file)
const uploaded = await FetchFormData<ResponseType>('/upload', formData)

// ❌ 错误示例 - 禁止直接使用 fetch
const response = await fetch('/api/endpoint') // 不要这样做
```

**FetchRequest 工具方法清单**:
- `FetchGet<T>(url, query?)` - GET 请求，查询参数通过 query 对象传递
- `FetchPost<T>(url, body?)` - POST 请求，数据通过 body 对象传递
- `FetchPut<T>(url, body?)` - PUT 请求，数据通过 body 对象传递
- `FetchDelete<T>(url, query?)` - DELETE 请求，查询参数通过 query 对象传递
- `FetchFormData<T>(url, formData)` - FormData 提交，用于文件上传

**使用规范**:
- 所有方法都支持泛型 `<T>` 指定返回类型
- 自动处理开发/生产环境的 API 地址切换
- 自动添加 `credentials: 'include'` 和 CORS 配置
- 自动设置正确的 Content-Type 头
- 集成统一的错误处理

#### 服务端请求解析规范 (必须遵守)
**必须使用 `@/utils/parseQuery.ts` 中的统一解析方法配合 Zod Schema 验证**

```typescript
// ✅ 正确示例
import { NextRequest } from 'next/server'
import { ParseGetQuery, ParsePostBody, ParsePutBody, ParseDeleteQuery, ParseFormData } from '@/utils/parseQuery'
import { z } from 'zod'

// 定义 Zod Schema
const GetQuerySchema = z.object({
  id: z.string(),
  page: z.string().optional()
})

// GET 请求解析
export async function GET(req: NextRequest) {
  const query = ParseGetQuery(req, GetQuerySchema)
  if (typeof query === 'string') {
    return Response.json({ error: query }, { status: 400 })
  }
  // 使用 query.id, query.page
}

// POST 请求解析
const PostBodySchema = z.object({
  name: z.string(),
  email: z.string().email()
})

export async function POST(req: NextRequest) {
  const body = await ParsePostBody(req, PostBodySchema)
  if (typeof body === 'string') {
    return Response.json({ error: body }, { status: 400 })
  }
  // 使用 body.name, body.email
}

// FormData 解析
const FormDataSchema = z.object({
  file: z.instanceof(File),
  description: z.string()
})

export async function POST(req: NextRequest) {
  const data = await ParseFormData(req, FormDataSchema)
  if (typeof data === 'string') {
    return Response.json({ error: data }, { status: 400 })
  }
  // 使用 data.file, data.description
}

// ❌ 错误示例 - 禁止直接解析
const body = await req.json() // 不要这样做，缺少验证
const { searchParams } = new URL(req.url) // 不要这样做，缺少验证
```

**ParseQuery 工具方法清单**:
- `ParseGetQuery<T>(req, schema)` - 解析 GET 查询参数
- `ParsePostBody<T>(req, schema)` - 解析 POST 请求体
- `ParsePutBody<T>(req, schema)` - 解析 PUT 请求体
- `ParseDeleteQuery<T>(req, schema)` - 解析 DELETE 查询参数
- `ParseFormData<T>(req, schema)` - 解析 FormData

**使用规范**:
- 所有方法必须配合 Zod Schema 使用，确保类型安全
- 返回值类型为 `z.infer<T> | string`，string 表示验证错误信息
- 必须检查返回值类型，如果是 string 则返回 400 错误
- 验证失败时返回清晰的 Zod 错误信息给客户端

#### API响应类型定义
```typescript
// 统一的API响应格式
interface ApiResponse<T> {
  data: T
  message: string
  status: number
}

// 分页响应格式
interface PaginatedResponse<T> {
  data: T[]
  pagination: {
    total: number
    page: number
    pageSize: number
    totalPages: number
  }
}
```

#### 错误处理
- 使用 `react-hot-toast` 显示用户友好的错误信息
- API错误统一处理，避免在组件中直接处理HTTP错误
- 使用Zod进行数据验证，确保类型安全
- 客户端使用 `fetch.ts` 的封装方法，自动处理错误
- 服务端使用 `parseQuery.ts` 的解析方法，自动验证数据

### 样式规范

#### Tailwind CSS使用
- 优先使用Tailwind工具类
- 复杂样式使用 `cn()` 函数合并类名
- 响应式设计使用移动优先原则
- 自定义组件样式使用CSS Modules或Sass

#### 暗黑模式支持
- 所有颜色使用语义化命名 (如 `text-foreground`, `bg-background`)
- 使用 `next-themes` 管理主题切换
- 确保所有组件在两种主题下都能正常显示

### 性能优化

#### 代码分割
- 使用动态导入 (`import()`) 进行路由级别的代码分割
- 大型组件使用 `React.lazy()` 懒加载
- 第三方库按需导入

#### 图片优化
- 使用 Next.js `Image` 组件
- 提供适当的 `alt` 文本
- 使用 Sharp 进行图片处理和优化

#### 缓存策略
- API响应使用适当的缓存策略
- 静态资源使用CDN加速
- 用户数据使用 localforage 本地缓存

### 安全规范

#### 数据验证
- 所有用户输入必须使用Zod验证
- API端点必须验证请求数据
- 敏感操作需要二次确认

#### 认证授权
- JWT Token安全存储和传输
- 基于角色的权限控制 (RBAC)
- 使用 Supabase 进行用户认证

### 测试规范 (推荐)

#### 组件测试
- 为关键组件编写单元测试
- 使用React Testing Library
- 测试用户交互和边界情况

#### 类型安全
- 启用TypeScript严格模式
- 避免使用 `any` 类型
- 为所有Props定义明确的接口

### 提交规范

#### 提交信息格式
```
<type>(<scope>): <description>

[optional body]

[optional footer]
```

类型 (type):
- `feat`: 新功能
- `fix`: 修复bug
- `docs`: 文档更新
- `style`: 代码格式化
- `refactor`: 代码重构
- `perf`: 性能优化
- `test`: 测试相关
- `chore`: 构建或工具更改

### 开发工具配置

#### VS Code推荐扩展
- TypeScript
- Tailwind CSS IntelliSense
- Prettier
- ESLint
- Auto Rename Tag
- Bracket Pair Colorizer

#### 开发命令
```bash
npm run dev          # 开发服务器 (Turbopack, 端口 9001)
npm run build        # 生产构建 (包含 PM2 自动重启)
npm run start        # 生产服务器
npm run lint         # ESLint检查
npm run format       # Prettier格式化
npm run prisma:generate  # 生成Prisma客户端
npm run prisma:push      # 推送数据库架构
npm run prisma:migrate   # 数据库迁移
npm run prisma:studio    # 打开Prisma Studio
```

### 特殊注意事项

#### 文件命名约定
- 组件目录使用 PascalCase (如 `PageContainer/`, `TopBar/`)
- 组件文件使用 PascalCase.tsx
- 工具文件使用 camelCase.ts
- 类型文件使用 kebab-case.d.ts

#### 导入路径别名
- 使用 `@/*` 指向 `src/*` 目录
- 避免使用相对路径导入深层组件

#### 状态管理
- 使用 Zustand 进行全局状态管理
- 每个功能模块创建独立的 store 文件
- 避免在组件中直接操作全局状态

遵循以上规范，确保项目代码质量、可维护性和团队协作效率。 